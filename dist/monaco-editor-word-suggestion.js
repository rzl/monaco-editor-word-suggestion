!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports["monaco-editor-word-suggestion"]=I():g["monaco-editor-word-suggestion"]=I()}(self,(()=>(()=>{var __webpack_modules__={975:module=>{eval("window.MonacoEditorWordSuggestion = class MonacoEditorWordSuggestion {\r\n    language = 'javascript'\r\n    monaco = window.monaco\r\n    autoRegister = true\r\n    disposeOther = true\r\n    tokenPattern = new RegExp('([a-zA-Z]+)', 'g');\r\n    baseTheme = 'vs-dark'\r\n    themeName = 'vs-dark'\r\n    provider = {\r\n        color: undefined,\r\n        hover: undefined,\r\n        completionItem: undefined\r\n    }\r\n    rules = [\r\n        {\r\n            token: 'that',\r\n            target: window.vue,\r\n            foreground: 'e23aff',\r\n            fontStyle: ''\r\n        },\r\n        {\r\n            token: 'theDate',\r\n            fnTarget: () => new Date(),\r\n            foreground: 'e23aff',\r\n            fontStyle: ''\r\n        }\r\n    ]\r\n    documentCache = {\r\n        ['that']: {\r\n            label: 'that',\r\n            documentation: { value: '## that document' }\r\n        }\r\n    }\r\n    get defaultSuggestion() {\r\n        return this.rules.map((rule) => {\r\n            return {\r\n                label: rule.token,\r\n                kind: this.monaco.languages.CompletionItemKind.Keyword,\r\n                insertText: rule.token\r\n            }\r\n        })\r\n    }\r\n    get targetMap() {\r\n        var map = {}\r\n        this.rules.forEach((r) => {\r\n            map[r.token] = r.target\r\n        })\r\n        return map\r\n    }\r\n    get legend() {\r\n        return {\r\n            tokenTypes: this.tokens,\r\n            tokenModifiers: []\r\n        }\r\n    }\r\n    get tokens() {\r\n        return this.rules.map(v => v.token)\r\n    }\r\n    get colorRules() {\r\n        return this.rules.map(v => ({\r\n            token: v.token,\r\n            foreground: v.foreground,\r\n            fontStyle: v.fontStyle\r\n        }))\r\n    }\r\n    get startsWiths() {\r\n        return this.rules.map(v => v.token + '.')\r\n    }\r\n    constructor(opt) {\r\n        Object.assign(this, opt)\r\n        if (this.autoRegister) {\r\n            this.register()\r\n        }\r\n        if (this.disposeOther) {\r\n            this.list.forEach(item => item.dispose())\r\n        }\r\n        this.list.push(this)\r\n    }\r\n    register(type) {\r\n        if (type) {\r\n            switch (type) {\r\n                case 'hover': this.registerHover()\r\n                    break;\r\n                case 'completionItem': this.registerCompletionItem()\r\n                    break;\r\n                case 'color':\r\n                    this.registerDocumentSemanticTokens()\r\n                    this.defineTheme()\r\n                    break;\r\n            }\r\n        } else {\r\n            this.registerHover()\r\n            this.registerCompletionItem()\r\n            this.registerDocumentSemanticTokens()\r\n            this.defineTheme()\r\n        }\r\n    }\r\n    dispose(type) {\r\n        if (type) {\r\n            switch (type) {\r\n                case 'hover': this.provider.hover && this.provider.hover.dispose()\r\n                    break;\r\n                case 'completionItem': this.provider.completionItem && this.provider.completionItem.dispose()\r\n                    break;\r\n                case 'color':\r\n                    this.provider.color && this.provider.color.dispose()\r\n                    break;\r\n            }\r\n        } else {\r\n            this.provider.completionItem && this.provider.completionItem.dispose()\r\n            this.provider.color && this.provider.color.dispose()\r\n            this.provider.hover && this.provider.hover.dispose()\r\n        }\r\n    }\r\n    keysSetCache() {\r\n\r\n    }\r\n    async ongGetAllkeys(wordword, setCahce) { }\r\n    async getAllkeys(wordword, obj) {\r\n        if (this.keysSetCache[wordword]) {\r\n            await this.ongGetAllkeys(wordword, this.keysSetCache[wordword])\r\n            return [...this.keysSetCache[wordword]]\r\n        }\r\n        const keys = []\r\n        let temp = obj\r\n        while (temp) {\r\n            keys.push.apply(keys, Object.getOwnPropertyNames(temp))\r\n            keys.push.apply(keys, Object.getOwnPropertySymbols(temp))\r\n            temp = Object.getPrototypeOf(temp)\r\n        }\r\n        this.keysSetCache[wordword] = new Set(keys.filter(o => typeof o == 'string' && o.indexOf('_') != 0))\r\n        await this.ongGetAllkeys(wordword, this.keysSetCache[wordword])\r\n        return [...this.keysSetCache[wordword]]\r\n    }\r\n    async onResolveWordHoverData(wordword, cache) { }\r\n    async resolveWordHoverData(wordword) {\r\n        if (!this.documentCache[wordword]) {\r\n            let obj = await this.resolveObj(wordword)\r\n            this.resolveSuggestion(wordword, obj, '')\r\n        }\r\n        await this.onResolveWordHoverData(wordword, this.documentCache[wordword])\r\n\r\n        return this.documentCache[wordword]\r\n    }\r\n    async onHover(wordword, res) { }\r\n    registerHover() {\r\n        let { monaco, language } = this\r\n        if (this.provider.hover) return\r\n        this.provider.hover = monaco.languages.registerHoverProvider(language, {\r\n            provideHover: async (model, position) => {\r\n                try {\r\n                    let pos = model.getWordAtPosition(position)\r\n                    if (!pos) return\r\n                    var wordword = model.getValueInRange({\r\n                        startLineNumber: position.lineNumber,\r\n                        startColumn: 1,\r\n                        endLineNumber: position.lineNumber,\r\n                        endColumn: model.getWordAtPosition(position).endColumn\r\n                    }).replace(/\\t/g, ' ').trim();\r\n                    if (wordword[wordword.length - 1] == '.') {\r\n                        wordword = wordword.substring(wordword.lastIndexOf(' ') + 1, wordword.length)\r\n                    }\r\n                    let data = await this.resolveWordHoverData(wordword)\r\n                    if (data) {\r\n                        var res = {\r\n                            contents: [\r\n                                { value: `**${data.label}**` },\r\n                                { value: data.documentation.value }\r\n                            ]\r\n                        };\r\n                        await this.onHover(wordword, res)\r\n                        return res\r\n                    }\r\n                } catch (e) {\r\n                    //  console.error(e)\r\n                }\r\n            }\r\n        });\r\n    }\r\n    resolveRule(wordword) {\r\n        return this.rules.find((rule) => {\r\n            return wordword.startsWith(`${rule.token}.`)\r\n        })\r\n    }\r\n    async resolveObj(wordword) {\r\n        try {\r\n            var rule = this.resolveRule(wordword)\r\n            if (rule) {\r\n                var target = rule.target\r\n                if (rule.fnTarget) {\r\n                    target = await rule.fnTarget()\r\n                }\r\n                var str = ''\r\n                if (wordword[wordword.length - 1] == '.') {\r\n                    str = wordword.substring(0, wordword.length - 1).replace(rule.token, 'target');\r\n                } else {\r\n                    str = wordword.substring(0, wordword.length).replace(rule.token, 'target');\r\n                }\r\n                return eval(str)\r\n            } else {\r\n                return undefined\r\n            }\r\n        } catch (e) {\r\n            return undefined\r\n        }\r\n    }\r\n    resolveSuggestion(wordword, obj, k) {\r\n        var { monaco, language } = this\r\n        if (this.documentCache[wordword + k]) {\r\n            var s = this.documentCache[wordword + k]\r\n            return {\r\n                label: s.label,\r\n                kind: s.kind,\r\n                documentation: s.documentation,\r\n                insertText: s.insertText\r\n            }\r\n        }\r\n        try {\r\n            let tmp = k !== '' ? obj[k] : obj\r\n            var res = {\r\n                label: k,\r\n                kind: typeof tmp === 'function' ? monaco.languages.CompletionItemKind.Function : monaco.languages.CompletionItemKind.Property,\r\n                documentation: {\r\n                    value: '```javascript\\n' +\r\n                        (typeof tmp === 'function' ? tmp.toString() : k) +\r\n                        '\\n```'\r\n                },\r\n                insertText: k\r\n            }\r\n        } catch (e) {\r\n            res = {\r\n                label: k,\r\n                kind: monaco.languages.CompletionItemKind.Property,\r\n                documentation: k,\r\n                insertText: k\r\n            }\r\n        }\r\n        if (!this.documentCache[wordword + k]) {\r\n            this.documentCache[wordword + k] = JSON.parse(JSON.stringify(res))\r\n        }\r\n        var s = this.documentCache[wordword + k]\r\n        return {\r\n            label: s.label,\r\n            kind: s.kind,\r\n            documentation: s.documentation,\r\n            insertText: s.insertText\r\n        }\r\n    }\r\n    async onCompletionItem(wordword, res) { }\r\n    registerCompletionItem() {\r\n        var { monaco, language } = this\r\n        if (this.provider.completionItem) return\r\n        this.provider.completionItem = monaco.languages.registerCompletionItemProvider(language, {\r\n            triggerCharacters: '.',\r\n            provideCompletionItems: async (model, position) => {\r\n                try {\r\n                    var wordword = model.getValueInRange({\r\n                        startLineNumber: position.lineNumber,\r\n                        startColumn: 1,\r\n                        endLineNumber: position.lineNumber,\r\n                        endColumn: position.column\r\n                    }).replace(/\\t/g, ' ').trim();\r\n                    if (wordword[wordword.length - 1] == '.') {\r\n                        wordword = wordword.substring(wordword.lastIndexOf(' ') + 1, wordword.length)\r\n                    }\r\n\r\n                    let obj = await this.resolveObj(wordword)\r\n                    debugger\r\n                    if (obj) {\r\n                        var keys = await this.getAllkeys(wordword, obj)\r\n                        let suggestions = keys.map((k) => {\r\n                            return this.resolveSuggestion(wordword, obj, k)\r\n                        });\r\n                        var res = { suggestions }\r\n                        await this.onCompletionItem(wordword, res)\r\n                        return res\r\n                    }\r\n\r\n                    var res = {\r\n                        suggestions: this.defaultSuggestion\r\n                    };\r\n                    await this.onCompletionItem(wordword, res)\r\n                    return res\r\n\r\n                } catch (e) {\r\n                    var res = {\r\n                        suggestions: this.defaultSuggestion\r\n                    };\r\n                    await this.onCompletionItem(wordword, res)\r\n                    return res\r\n                }\r\n            }\r\n        });\r\n    }\r\n    defineTheme() {\r\n        this.monaco.editor.defineTheme(this.themeName, {\r\n            base: this.baseTheme,\r\n            inherit: true,\r\n            colors: {},\r\n            rules: this.colorRules\r\n        })\r\n    }\r\n    getType(type) {\r\n        return this.legend.tokenTypes.indexOf(type);\r\n    }\r\n    registerDocumentSemanticTokens() {\r\n        let { monaco, language, tokenPattern } = this\r\n        if (this.provider.color) return\r\n        this.provider.color = monaco.languages.registerDocumentSemanticTokensProvider(language, {\r\n            getLegend: () => {\r\n                return this.legend;\r\n            },\r\n            provideDocumentSemanticTokens: (model, lastResultId, token) => {\r\n                const lines = model.getLinesContent();\r\n\r\n                const data = [];\r\n\r\n                let prevLine = 0;\r\n                let prevChar = 0;\r\n\r\n                for (let i = 0; i < lines.length; i++) {\r\n                    const line = lines[i];\r\n\r\n                    for (let match = null; (match = tokenPattern.exec(line));) {\r\n                        // translate token and modifiers to number representations\r\n                        let type = this.getType(match[1]);\r\n                        if (type === -1) {\r\n                            continue;\r\n                        }\r\n                        let modifier = 0;\r\n\r\n                        data.push(\r\n                            // translate line to deltaLine\r\n                            i - prevLine,\r\n                            // for the same line, translate start to deltaStart\r\n                            prevLine === i ? match.index - prevChar : match.index,\r\n                            match[0].length,\r\n                            type,\r\n                            modifier\r\n                        );\r\n\r\n                        prevLine = i;\r\n                        prevChar = match.index;\r\n                    }\r\n                }\r\n                return {\r\n                    data: new Uint32Array(data),\r\n                    resultId: null\r\n                };\r\n            },\r\n            releaseDocumentSemanticTokens: function (resultId) { }\r\n        });\r\n    }\r\n}\r\nMonacoEditorWordSuggestion.prototype.list = []\r\n\r\nmodule.exports = MonacoEditorWordSuggestion\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSwyQ0FBMkMsa0NBQWtDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25hY28tZWRpdG9yLXdvcmQtc3VnZ2VzdGlvbi8uL2FwcC9tYWluLmpzP2YxNjEiXSwic291cmNlc0NvbnRlbnQiOlsid2luZG93Lk1vbmFjb0VkaXRvcldvcmRTdWdnZXN0aW9uID0gY2xhc3MgTW9uYWNvRWRpdG9yV29yZFN1Z2dlc3Rpb24ge1xyXG4gICAgbGFuZ3VhZ2UgPSAnamF2YXNjcmlwdCdcclxuICAgIG1vbmFjbyA9IHdpbmRvdy5tb25hY29cclxuICAgIGF1dG9SZWdpc3RlciA9IHRydWVcclxuICAgIGRpc3Bvc2VPdGhlciA9IHRydWVcclxuICAgIHRva2VuUGF0dGVybiA9IG5ldyBSZWdFeHAoJyhbYS16QS1aXSspJywgJ2cnKTtcclxuICAgIGJhc2VUaGVtZSA9ICd2cy1kYXJrJ1xyXG4gICAgdGhlbWVOYW1lID0gJ3ZzLWRhcmsnXHJcbiAgICBwcm92aWRlciA9IHtcclxuICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhvdmVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY29tcGxldGlvbkl0ZW06IHVuZGVmaW5lZFxyXG4gICAgfVxyXG4gICAgcnVsZXMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0b2tlbjogJ3RoYXQnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHdpbmRvdy52dWUsXHJcbiAgICAgICAgICAgIGZvcmVncm91bmQ6ICdlMjNhZmYnLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6ICcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRva2VuOiAndGhlRGF0ZScsXHJcbiAgICAgICAgICAgIGZuVGFyZ2V0OiAoKSA9PiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICBmb3JlZ3JvdW5kOiAnZTIzYWZmJyxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiAnJ1xyXG4gICAgICAgIH1cclxuICAgIF1cclxuICAgIGRvY3VtZW50Q2FjaGUgPSB7XHJcbiAgICAgICAgWyd0aGF0J106IHtcclxuICAgICAgICAgICAgbGFiZWw6ICd0aGF0JyxcclxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogeyB2YWx1ZTogJyMjIHRoYXQgZG9jdW1lbnQnIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZGVmYXVsdFN1Z2dlc3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXMubWFwKChydWxlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogcnVsZS50b2tlbixcclxuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMubW9uYWNvLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCxcclxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHJ1bGUudG9rZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBnZXQgdGFyZ2V0TWFwKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB7fVxyXG4gICAgICAgIHRoaXMucnVsZXMuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICAgICAgICBtYXBbci50b2tlbl0gPSByLnRhcmdldFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgfVxyXG4gICAgZ2V0IGxlZ2VuZCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b2tlblR5cGVzOiB0aGlzLnRva2VucyxcclxuICAgICAgICAgICAgdG9rZW5Nb2RpZmllcnM6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHRva2VucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlcy5tYXAodiA9PiB2LnRva2VuKVxyXG4gICAgfVxyXG4gICAgZ2V0IGNvbG9yUnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXMubWFwKHYgPT4gKHtcclxuICAgICAgICAgICAgdG9rZW46IHYudG9rZW4sXHJcbiAgICAgICAgICAgIGZvcmVncm91bmQ6IHYuZm9yZWdyb3VuZCxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiB2LmZvbnRTdHlsZVxyXG4gICAgICAgIH0pKVxyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0c1dpdGhzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzLm1hcCh2ID0+IHYudG9rZW4gKyAnLicpXHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdClcclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVnaXN0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcigpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VPdGhlcikge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3QuZm9yRWFjaChpdGVtID0+IGl0ZW0uZGlzcG9zZSgpKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpc3QucHVzaCh0aGlzKVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXIodHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaG92ZXInOiB0aGlzLnJlZ2lzdGVySG92ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGlvbkl0ZW0nOiB0aGlzLnJlZ2lzdGVyQ29tcGxldGlvbkl0ZW0oKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJEb2N1bWVudFNlbWFudGljVG9rZW5zKClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZVRoZW1lKClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJIb3ZlcigpXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb21wbGV0aW9uSXRlbSgpXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJEb2N1bWVudFNlbWFudGljVG9rZW5zKClcclxuICAgICAgICAgICAgdGhpcy5kZWZpbmVUaGVtZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdob3Zlcic6IHRoaXMucHJvdmlkZXIuaG92ZXIgJiYgdGhpcy5wcm92aWRlci5ob3Zlci5kaXNwb3NlKClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRpb25JdGVtJzogdGhpcy5wcm92aWRlci5jb21wbGV0aW9uSXRlbSAmJiB0aGlzLnByb3ZpZGVyLmNvbXBsZXRpb25JdGVtLmRpc3Bvc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuY29sb3IgJiYgdGhpcy5wcm92aWRlci5jb2xvci5kaXNwb3NlKClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuY29tcGxldGlvbkl0ZW0gJiYgdGhpcy5wcm92aWRlci5jb21wbGV0aW9uSXRlbS5kaXNwb3NlKClcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5jb2xvciAmJiB0aGlzLnByb3ZpZGVyLmNvbG9yLmRpc3Bvc2UoKVxyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmhvdmVyICYmIHRoaXMucHJvdmlkZXIuaG92ZXIuZGlzcG9zZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAga2V5c1NldENhY2hlKCkge1xyXG5cclxuICAgIH1cclxuICAgIGFzeW5jIG9uZ0dldEFsbGtleXMod29yZHdvcmQsIHNldENhaGNlKSB7IH1cclxuICAgIGFzeW5jIGdldEFsbGtleXMod29yZHdvcmQsIG9iaikge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNTZXRDYWNoZVt3b3Jkd29yZF0pIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5vbmdHZXRBbGxrZXlzKHdvcmR3b3JkLCB0aGlzLmtleXNTZXRDYWNoZVt3b3Jkd29yZF0pXHJcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy5rZXlzU2V0Q2FjaGVbd29yZHdvcmRdXVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gW11cclxuICAgICAgICBsZXQgdGVtcCA9IG9ialxyXG4gICAgICAgIHdoaWxlICh0ZW1wKSB7XHJcbiAgICAgICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZW1wKSlcclxuICAgICAgICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGVtcCkpXHJcbiAgICAgICAgICAgIHRlbXAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGVtcClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5rZXlzU2V0Q2FjaGVbd29yZHdvcmRdID0gbmV3IFNldChrZXlzLmZpbHRlcihvID0+IHR5cGVvZiBvID09ICdzdHJpbmcnICYmIG8uaW5kZXhPZignXycpICE9IDApKVxyXG4gICAgICAgIGF3YWl0IHRoaXMub25nR2V0QWxsa2V5cyh3b3Jkd29yZCwgdGhpcy5rZXlzU2V0Q2FjaGVbd29yZHdvcmRdKVxyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5rZXlzU2V0Q2FjaGVbd29yZHdvcmRdXVxyXG4gICAgfVxyXG4gICAgYXN5bmMgb25SZXNvbHZlV29yZEhvdmVyRGF0YSh3b3Jkd29yZCwgY2FjaGUpIHsgfVxyXG4gICAgYXN5bmMgcmVzb2x2ZVdvcmRIb3ZlckRhdGEod29yZHdvcmQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRDYWNoZVt3b3Jkd29yZF0pIHtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IGF3YWl0IHRoaXMucmVzb2x2ZU9iaih3b3Jkd29yZClcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3VnZ2VzdGlvbih3b3Jkd29yZCwgb2JqLCAnJylcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy5vblJlc29sdmVXb3JkSG92ZXJEYXRhKHdvcmR3b3JkLCB0aGlzLmRvY3VtZW50Q2FjaGVbd29yZHdvcmRdKVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlW3dvcmR3b3JkXVxyXG4gICAgfVxyXG4gICAgYXN5bmMgb25Ib3Zlcih3b3Jkd29yZCwgcmVzKSB7IH1cclxuICAgIHJlZ2lzdGVySG92ZXIoKSB7XHJcbiAgICAgICAgbGV0IHsgbW9uYWNvLCBsYW5ndWFnZSB9ID0gdGhpc1xyXG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyLmhvdmVyKSByZXR1cm5cclxuICAgICAgICB0aGlzLnByb3ZpZGVyLmhvdmVyID0gbW9uYWNvLmxhbmd1YWdlcy5yZWdpc3RlckhvdmVyUHJvdmlkZXIobGFuZ3VhZ2UsIHtcclxuICAgICAgICAgICAgcHJvdmlkZUhvdmVyOiBhc3luYyAobW9kZWwsIHBvc2l0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbihwb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcykgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmR3b3JkID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBwb3NpdGlvbi5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcG9zaXRpb24ubGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbihwb3NpdGlvbikuZW5kQ29sdW1uXHJcbiAgICAgICAgICAgICAgICAgICAgfSkucmVwbGFjZSgvXFx0L2csICcgJykudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3Jkd29yZFt3b3Jkd29yZC5sZW5ndGggLSAxXSA9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZHdvcmQgPSB3b3Jkd29yZC5zdWJzdHJpbmcod29yZHdvcmQubGFzdEluZGV4T2YoJyAnKSArIDEsIHdvcmR3b3JkLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLnJlc29sdmVXb3JkSG92ZXJEYXRhKHdvcmR3b3JkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IGAqKiR7ZGF0YS5sYWJlbH0qKmAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBkYXRhLmRvY3VtZW50YXRpb24udmFsdWUgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9uSG92ZXIod29yZHdvcmQsIHJlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5lcnJvcihlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlUnVsZSh3b3Jkd29yZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmZpbmQoKHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHdvcmR3b3JkLnN0YXJ0c1dpdGgoYCR7cnVsZS50b2tlbn0uYClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVzb2x2ZU9iaih3b3Jkd29yZCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlID0gdGhpcy5yZXNvbHZlUnVsZSh3b3Jkd29yZClcclxuICAgICAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBydWxlLnRhcmdldFxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZm5UYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBhd2FpdCBydWxlLmZuVGFyZ2V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSAnJ1xyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmR3b3JkW3dvcmR3b3JkLmxlbmd0aCAtIDFdID09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHdvcmR3b3JkLnN1YnN0cmluZygwLCB3b3Jkd29yZC5sZW5ndGggLSAxKS5yZXBsYWNlKHJ1bGUudG9rZW4sICd0YXJnZXQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gd29yZHdvcmQuc3Vic3RyaW5nKDAsIHdvcmR3b3JkLmxlbmd0aCkucmVwbGFjZShydWxlLnRva2VuLCAndGFyZ2V0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbChzdHIpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNvbHZlU3VnZ2VzdGlvbih3b3Jkd29yZCwgb2JqLCBrKSB7XHJcbiAgICAgICAgdmFyIHsgbW9uYWNvLCBsYW5ndWFnZSB9ID0gdGhpc1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2FjaGVbd29yZHdvcmQgKyBrXSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuZG9jdW1lbnRDYWNoZVt3b3Jkd29yZCArIGtdXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogcy5sYWJlbCxcclxuICAgICAgICAgICAgICAgIGtpbmQ6IHMua2luZCxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHMuZG9jdW1lbnRhdGlvbixcclxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHMuaW5zZXJ0VGV4dFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCB0bXAgPSBrICE9PSAnJyA/IG9ialtrXSA6IG9ialxyXG4gICAgICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGssXHJcbiAgICAgICAgICAgICAgICBraW5kOiB0eXBlb2YgdG1wID09PSAnZnVuY3Rpb24nID8gbW9uYWNvLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gOiBtb25hY28ubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ2BgYGphdmFzY3JpcHRcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiB0bXAgPT09ICdmdW5jdGlvbicgPyB0bXAudG9TdHJpbmcoKSA6IGspICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbmBgYCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBrLFxyXG4gICAgICAgICAgICAgICAga2luZDogbW9uYWNvLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBrLFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDoga1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5kb2N1bWVudENhY2hlW3dvcmR3b3JkICsga10pIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlW3dvcmR3b3JkICsga10gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzID0gdGhpcy5kb2N1bWVudENhY2hlW3dvcmR3b3JkICsga11cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYWJlbDogcy5sYWJlbCxcclxuICAgICAgICAgICAga2luZDogcy5raW5kLFxyXG4gICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBzLmRvY3VtZW50YXRpb24sXHJcbiAgICAgICAgICAgIGluc2VydFRleHQ6IHMuaW5zZXJ0VGV4dFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uQ29tcGxldGlvbkl0ZW0od29yZHdvcmQsIHJlcykgeyB9XHJcbiAgICByZWdpc3RlckNvbXBsZXRpb25JdGVtKCkge1xyXG4gICAgICAgIHZhciB7IG1vbmFjbywgbGFuZ3VhZ2UgfSA9IHRoaXNcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlci5jb21wbGV0aW9uSXRlbSkgcmV0dXJuXHJcbiAgICAgICAgdGhpcy5wcm92aWRlci5jb21wbGV0aW9uSXRlbSA9IG1vbmFjby5sYW5ndWFnZXMucmVnaXN0ZXJDb21wbGV0aW9uSXRlbVByb3ZpZGVyKGxhbmd1YWdlLCB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJDaGFyYWN0ZXJzOiAnLicsXHJcbiAgICAgICAgICAgIHByb3ZpZGVDb21wbGV0aW9uSXRlbXM6IGFzeW5jIChtb2RlbCwgcG9zaXRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmR3b3JkID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBwb3NpdGlvbi5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcG9zaXRpb24ubGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBwb3NpdGlvbi5jb2x1bW5cclxuICAgICAgICAgICAgICAgICAgICB9KS5yZXBsYWNlKC9cXHQvZywgJyAnKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmR3b3JkW3dvcmR3b3JkLmxlbmd0aCAtIDFdID09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkd29yZCA9IHdvcmR3b3JkLnN1YnN0cmluZyh3b3Jkd29yZC5sYXN0SW5kZXhPZignICcpICsgMSwgd29yZHdvcmQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IGF3YWl0IHRoaXMucmVzb2x2ZU9iaih3b3Jkd29yZClcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBhd2FpdCB0aGlzLmdldEFsbGtleXMod29yZHdvcmQsIG9iailcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Z2dlc3Rpb25zID0ga2V5cy5tYXAoKGspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVTdWdnZXN0aW9uKHdvcmR3b3JkLCBvYmosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0geyBzdWdnZXN0aW9ucyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub25Db21wbGV0aW9uSXRlbSh3b3Jkd29yZCwgcmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogdGhpcy5kZWZhdWx0U3VnZ2VzdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vbkNvbXBsZXRpb25JdGVtKHdvcmR3b3JkLCByZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc1xyXG5cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogdGhpcy5kZWZhdWx0U3VnZ2VzdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vbkNvbXBsZXRpb25JdGVtKHdvcmR3b3JkLCByZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZpbmVUaGVtZSgpIHtcclxuICAgICAgICB0aGlzLm1vbmFjby5lZGl0b3IuZGVmaW5lVGhlbWUodGhpcy50aGVtZU5hbWUsIHtcclxuICAgICAgICAgICAgYmFzZTogdGhpcy5iYXNlVGhlbWUsXHJcbiAgICAgICAgICAgIGluaGVyaXQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbG9yczoge30sXHJcbiAgICAgICAgICAgIHJ1bGVzOiB0aGlzLmNvbG9yUnVsZXNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgZ2V0VHlwZSh0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kLnRva2VuVHlwZXMuaW5kZXhPZih0eXBlKTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyRG9jdW1lbnRTZW1hbnRpY1Rva2VucygpIHtcclxuICAgICAgICBsZXQgeyBtb25hY28sIGxhbmd1YWdlLCB0b2tlblBhdHRlcm4gfSA9IHRoaXNcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlci5jb2xvcikgcmV0dXJuXHJcbiAgICAgICAgdGhpcy5wcm92aWRlci5jb2xvciA9IG1vbmFjby5sYW5ndWFnZXMucmVnaXN0ZXJEb2N1bWVudFNlbWFudGljVG9rZW5zUHJvdmlkZXIobGFuZ3VhZ2UsIHtcclxuICAgICAgICAgICAgZ2V0TGVnZW5kOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb3ZpZGVEb2N1bWVudFNlbWFudGljVG9rZW5zOiAobW9kZWwsIGxhc3RSZXN1bHRJZCwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gbW9kZWwuZ2V0TGluZXNDb250ZW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBwcmV2TGluZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJldkNoYXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG1hdGNoID0gbnVsbDsgKG1hdGNoID0gdG9rZW5QYXR0ZXJuLmV4ZWMobGluZSkpOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgdG9rZW4gYW5kIG1vZGlmaWVycyB0byBudW1iZXIgcmVwcmVzZW50YXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5nZXRUeXBlKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGxpbmUgdG8gZGVsdGFMaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC0gcHJldkxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIHNhbWUgbGluZSwgdHJhbnNsYXRlIHN0YXJ0IHRvIGRlbHRhU3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZMaW5lID09PSBpID8gbWF0Y2guaW5kZXggLSBwcmV2Q2hhciA6IG1hdGNoLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDaGFyID0gbWF0Y2guaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBuZXcgVWludDMyQXJyYXkoZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWQ6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlbGVhc2VEb2N1bWVudFNlbWFudGljVG9rZW5zOiBmdW5jdGlvbiAocmVzdWx0SWQpIHsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbk1vbmFjb0VkaXRvcldvcmRTdWdnZXN0aW9uLnByb3RvdHlwZS5saXN0ID0gW11cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9uYWNvRWRpdG9yV29yZFN1Z2dlc3Rpb25cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///975\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](C,C.exports,__webpack_require__),C.exports}var __webpack_exports__=__webpack_require__(975);return __webpack_exports__})()));